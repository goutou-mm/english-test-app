<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI è‹±è¯­èƒ½åŠ›æµ‹è¯„</title>
    <link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/vant@3/lib/index.css"/>
    <script src="https://fastly.jsdelivr.net/npm/vue@3"></script>
    <script src="https://fastly.jsdelivr.net/npm/vant@3/lib/vant.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            padding: 0;
        }
        .app-container { 
            max-width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        /* é¡¶éƒ¨è¿›åº¦æ¡ */
        .progress-header {
            background: white;
            padding: 15px 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .progress-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .progress-text {
            font-size: 14px;
            color: #666;
        }
        .progress-text strong {
            color: #667eea;
            font-size: 16px;
        }
        .timer {
            background: #f0f0f0;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
            color: #333;
        }
        .progress-bar-container {
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s ease;
        }
        
        /* é¢˜ç›®å¡ç‰‡å®¹å™¨ */
        .question-container {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            display: flex;
            align-items: flex-start; /* é¡¶éƒ¨å¯¹é½ï¼Œé¿å…è¢«è¿›åº¦æ¡é®æŒ¡ */
            justify-content: center;
            padding-top: 10px;
        }
        
        /* é¢˜ç›®å¡ç‰‡ */
        .question-card {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 100%;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            animation: slideIn 0.3s ease-out;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        /* é¢˜ç›®ç±»å‹æ ‡ç­¾ */
        .question-type {
            display: inline-block;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 14px;
            margin-bottom: 15px;
            font-weight: 500;
        }
        
        /* é¢˜ç›®è¯´æ˜ */
        .question-instruction {
            background: #f8f9fa;
            padding: 12px 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 13px;
            color: #666;
            border-left: 3px solid #667eea;
        }
        
        /* å¬åŠ›æ’­æ”¾æŒ‰é’® */
        .audio-player {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        .audio-player:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        .audio-player.playing {
            background: linear-gradient(135deg, #f56c6c 0%, #e74c3c 100%);
        }
        .audio-icon {
            font-size: 40px;
            margin-bottom: 10px;
        }
        .audio-text {
            color: white;
            font-size: 16px;
            font-weight: 500;
        }
        .audio-count {
            color: rgba(255,255,255,0.9);
            font-size: 12px;
            margin-top: 5px;
        }
        
        /* é˜…è¯»ææ–™ */
        .reading-passage {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            border-left: 4px solid #667eea;
            line-height: 1.8;
            font-size: 15px;
        }
        
        /* é¢˜ç›®æ–‡æœ¬ */
        .question-text {
            font-size: 18px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 20px;
            line-height: 1.6;
        }
        
        /* é€‰é¡¹æ ·å¼ */
        .options-container {
            margin-bottom: 30px;
        }
        .option-item {
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
        }
        .option-item:hover {
            border-color: #667eea;
            background: #f0f3ff;
        }
        .option-item.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, #f0f3ff 0%, #e8ecff 100%);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
        }
        .option-label {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: white;
            border: 2px solid #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
        }
        .option-item.selected .option-label {
            background: #667eea;
            border-color: #667eea;
            color: white;
        }
        .option-text {
            flex: 1;
            font-size: 16px;
            color: #2c3e50;
        }
        
        /* åº•éƒ¨æŒ‰é’® */
        .button-container {
            padding: 20px;
            background: white;
            box-shadow: 0 -2px 8px rgba(0,0,0,0.1);
            display: flex;
            gap: 10px;
        }
        .btn {
            flex: 1;
            height: 50px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        .btn-prev {
            background: #f0f0f0;
            color: #666;
        }
        .btn-prev:hover {
            background: #e0e0e0;
        }
        .btn-prev:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-next {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .btn-next:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        .btn-submit {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }
        
        /* å“åº”å¼ */
        @media (max-width: 768px) {
            .question-card {
                padding: 20px;
                margin-top: 0; /* ç§»é™¤é¡¶éƒ¨margin */
            }
            .question-text {
                font-size: 16px;
            }
            .question-container {
                padding: 10px; /* ç§»åŠ¨ç«¯å‡å°‘padding */
                padding-top: 5px;
            }
            .progress-header {
                padding: 12px 15px; /* ç§»åŠ¨ç«¯ç¼©å°è¿›åº¦æ¡é«˜åº¦ */
            }
            .question-type {
                font-size: 13px; /* ç§»åŠ¨ç«¯ç¨å°å­—ä½“ */
                padding: 6px 15px;
            }
        }
    </style>
</head>
<body>
<div id="app" class="app-container">
    <!-- é¡¶éƒ¨è¿›åº¦æ¡ -->
    <div class="progress-header">
        <div class="progress-info">
            <div class="progress-text">
                ç¬¬ <strong>{{ currentIndex + 1 }}</strong> / {{ questions.length }} é¢˜
            </div>
            <div class="timer">â±ï¸ {{ formatTime(totalTime) }}</div>
        </div>
        <div class="progress-bar-container">
            <div class="progress-bar" :style="{ width: progressPercent + '%' }"></div>
        </div>
    </div>
    
    <!-- é¢˜ç›®å®¹å™¨ -->
    <div class="question-container" v-if="questions.length > 0">
        <div class="question-card">
            <!-- é¢˜ç›®ç±»å‹æ ‡ç­¾ -->
            <div class="question-type">
                {{ currentQuestion.typeLabel }}
            </div>
            
            <!-- é¢˜ç›®è¯´æ˜ -->
            <div class="question-instruction">
                {{ currentQuestion.instruction }}
            </div>
            
            <!-- å¬åŠ›æ’­æ”¾å™¨ -->
            <div v-if="currentQuestion.audio_text" 
                 class="audio-player" 
                 :class="{ playing: currentPlayingIndex === currentIndex }"
                 @click="toggleAudio(currentQuestion.audio_text, currentIndex)">
                <div class="audio-icon">
                    {{ currentPlayingIndex === currentIndex ? 'â¹ï¸' : 'ğŸ”Š' }}
                </div>
                <div class="audio-text">
                    {{ currentPlayingIndex === currentIndex ? 'ç‚¹å‡»åœæ­¢æ’­æ”¾' : 'ç‚¹å‡»æ’­æ”¾éŸ³é¢‘' }}
                </div>
                <div class="audio-count">
                    å·²æ’­æ”¾ {{ questionMetrics[currentIndex].audioPlayCount }} æ¬¡
                </div>
            </div>
            
            <!-- é˜…è¯»ææ–™ -->
            <div v-if="currentQuestion.passage" class="reading-passage">
                {{ currentQuestion.passage }}
            </div>
            
            <!-- é¢˜ç›®æ–‡æœ¬ -->
            <div class="question-text">
                {{ currentQuestion.question }}
            </div>
            
            <!-- é€‰é¡¹ -->
            <div class="options-container">
                <div v-for="(option, index) in currentQuestion.options" 
                     :key="index"
                     class="option-item"
                     :class="{ selected: userAnswers[currentIndex] === option }"
                     @click="selectOption(option)">
                    <div class="option-label">{{ ['A', 'B', 'C', 'D'][index] }}</div>
                    <div class="option-text">{{ option }}</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- åŠ è½½çŠ¶æ€ -->
    <van-empty v-else description="è¯•å·åŠ è½½ä¸­..." image="search"></van-empty>
    
    <!-- åº•éƒ¨æŒ‰é’® -->
    <div class="button-container" v-if="questions.length > 0">
        <button class="btn btn-prev" 
                @click="prevQuestion" 
                :disabled="currentIndex === 0">
            â† ä¸Šä¸€é¢˜
        </button>
        <button v-if="currentIndex < questions.length - 1" 
                class="btn btn-next" 
                @click="nextQuestion">
            ä¸‹ä¸€é¢˜ â†’
        </button>
        <button v-else 
                class="btn btn-submit" 
                @click="submitTest">
            æäº¤æµ‹éªŒ
        </button>
    </div>
</div>

<script>
    const app = Vue.createApp({
        data() { 
            return { 
                questions: [],
                userAnswers: [],
                currentIndex: 0,           // å½“å‰é¢˜ç›®ç´¢å¼•
                debugMode: false,
                debugInfo: '',
                
                // å­¦ä¹ è¡Œä¸ºæ•°æ®è¿½è¸ª
                testStartTime: null,
                totalTime: 0,
                timerInterval: null,
                questionMetrics: [],
                currentPlayingIndex: null,
                
                // é˜²åˆ·åˆ†
                hasSubmitted: false,
                submissionLocked: false
            }; 
        },
        computed: {
            currentQuestion() {
                return this.questions[this.currentIndex] || {};
            },
            progressPercent() {
                return ((this.currentIndex + 1) / this.questions.length) * 100;
            }
        },
        created() {
            this.loadQuestions();
            this.checkSubmissionStatus();
        },
        mounted() {
            this.startTimer();
            this.preventBackNavigation();
        },
        beforeUnmount() {
            if (this.timerInterval) clearInterval(this.timerInterval);
            window.speechSynthesis.cancel();
        },
        methods: {
            async loadQuestions() {
                const urlParams = new URLSearchParams(window.location.search);
                const recordId = urlParams.get('rid');
                
                if (!recordId) {
                    vant.Toast.fail("ç¼ºå°‘è®°å½•IDå‚æ•°");
                    return;
                }
                
                try {
                    // æ˜¾ç¤ºåŠ è½½æç¤º
                    vant.Toast.loading({
                        message: 'åŠ è½½é¢˜ç›®ä¸­...',
                        forbidClick: true,
                        duration: 0
                    });
                    
                    // ===== ä»APIè¯»å–é¢˜ç›®æ•°æ® =====
                    // TODO: æ›¿æ¢ä¸ºä½ éƒ¨ç½²çš„Vercelåœ°å€
                    const apiUrl = '/api/get-test-data';
                    const response = await fetch(`${apiUrl}?rid=${recordId}`);
                    
                    if (!response.ok) {
                        throw new Error('åŠ è½½é¢˜ç›®å¤±è´¥');
                    }
                    
                    const result = await response.json();
                    
                    vant.Toast.clear();
                    
                    if (!result.success) {
                        throw new Error(result.error || 'æ•°æ®åŠ è½½å¤±è´¥');
                    }
                    
                    // æå–æ•°æ®
                    const { studentName, questions } = result.data;
                    
                    if (questions && questions.length > 0) {
                        this.questions = questions;
                        this.userAnswers = new Array(this.questions.length).fill('');
                        this.initQuestionMetrics();
                        
                        // å¼€å§‹ç¬¬ä¸€é¢˜è®¡æ—¶
                        this.questionMetrics[0].startTime = Date.now();
                        
                        // å­˜å‚¨å­¦ç”Ÿå§“åï¼ˆç”¨äºåç»­æäº¤ï¼‰
                        sessionStorage.setItem('studentName', studentName);
                        
                        vant.Toast.success('é¢˜ç›®åŠ è½½æˆåŠŸ');
                    } else {
                        throw new Error('é¢˜ç›®æ•°æ®ä¸ºç©º');
                    }
                    
                } catch (error) { 
                    console.error('é¢˜ç›®åŠ è½½é”™è¯¯:', error);
                    vant.Toast.clear();
                    
                    // å¦‚æœAPIå¤±è´¥ï¼Œé™çº§åˆ°URLå‚æ•°æ–¹å¼ï¼ˆå…¼å®¹æ—§é“¾æ¥ï¼‰
                    this.loadQuestionsFromUrl();
                }
            },
            
            /**
             * å¤‡ç”¨æ–¹æ¡ˆï¼šä»URLå‚æ•°è¯»å–ï¼ˆå…¼å®¹æ—§é“¾æ¥ï¼‰
             */
            loadQuestionsFromUrl() {
                const urlParams = new URLSearchParams(window.location.search);
                const rawData = urlParams.get('data');
                
                if (!rawData) {
                    vant.Toast.fail("æœªæ‰¾åˆ°é¢˜ç›®æ•°æ®");
                    return;
                }
                
                try {
                    let text = decodeURIComponent(rawData);
                    let parsed = JSON.parse(text);
                    let questionsArray = null;
                    
                    if (parsed.output && parsed.output.choices && parsed.output.choices[0]) {
                        const content = parsed.output.choices[0].message.content;
                        questionsArray = JSON.parse(content);
                    } else if (Array.isArray(parsed)) {
                        questionsArray = parsed;
                    } else if (parsed.questions) {
                        questionsArray = parsed.questions;
                    } else {
                        const match = text.match(/\[\s*\{.*\}\s*\]/s);
                        if (match) questionsArray = JSON.parse(match[0]);
                    }
                    
                    if (questionsArray && questionsArray.length > 0) {
                        this.questions = questionsArray;
                        this.userAnswers = new Array(this.questions.length).fill('');
                        this.initQuestionMetrics();
                        this.questionMetrics[0].startTime = Date.now();
                    } else {
                        throw new Error('é¢˜ç›®æ•°ç»„ä¸ºç©º');
                    }
                } catch (e) { 
                    console.error('é¢˜ç›®è§£æé”™è¯¯:', e);
                    vant.Toast.fail("é¢˜ç›®åŠ è½½å¤±è´¥"); 
                }
            },
            
            initQuestionMetrics() {
                this.questionMetrics = this.questions.map((q, index) => {
                    return {
                        questionIndex: index + 1,
                        startTime: null,
                        timeSpent: 0,
                        isCorrect: false,
                        userAnswer: '',
                        correctAnswer: q.answer,
                        changeCount: 0,
                        audioPlayCount: 0,
                        questionType: q.questionType || 'å…¶ä»–',
                        questionText: q.question || q.audio_text || ''
                    };
                });
            },
            
            startTimer() {
                this.testStartTime = Date.now();
                this.timerInterval = setInterval(() => {
                    this.totalTime = Math.floor((Date.now() - this.testStartTime) / 1000);
                }, 1000);
            },
            
            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            },
            
            selectOption(option) {
                if (this.submissionLocked) return;
                
                const metric = this.questionMetrics[this.currentIndex];
                
                // è®°å½•ä¿®æ”¹æ¬¡æ•°
                if (metric.userAnswer && metric.userAnswer !== option) {
                    metric.changeCount++;
                }
                
                metric.userAnswer = option;
                this.userAnswers[this.currentIndex] = option;
            },
            
            nextQuestion() {
                // è®°å½•å½“å‰é¢˜ç”¨æ—¶
                this.recordQuestionTime(this.currentIndex);
                
                if (this.currentIndex < this.questions.length - 1) {
                    this.currentIndex++;
                    
                    // å¼€å§‹æ–°é¢˜è®¡æ—¶
                    const metric = this.questionMetrics[this.currentIndex];
                    if (!metric.startTime) {
                        metric.startTime = Date.now();
                    }
                    
                    // åœæ­¢éŸ³é¢‘
                    this.stopAudio();
                }
            },
            
            prevQuestion() {
                this.recordQuestionTime(this.currentIndex);
                
                if (this.currentIndex > 0) {
                    this.currentIndex--;
                    this.stopAudio();
                }
            },
            
            recordQuestionTime(index) {
                const metric = this.questionMetrics[index];
                if (metric.startTime) {
                    metric.timeSpent = (Date.now() - metric.startTime) / 1000;
                }
            },
            
            toggleAudio(text, index) {
                if (this.currentPlayingIndex === index) {
                    this.stopAudio();
                } else {
                    this.playAudio(text, index);
                }
            },
            
            playAudio(text, index) {
                this.questionMetrics[index].audioPlayCount++;
                window.speechSynthesis.cancel();
                
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'en-US';
                utterance.rate = 0.9;
                
                this.currentPlayingIndex = index;
                
                utterance.onend = () => {
                    this.currentPlayingIndex = null;
                };
                
                utterance.onerror = () => {
                    this.currentPlayingIndex = null;
                };
                
                window.speechSynthesis.speak(utterance);
            },
            
            stopAudio() {
                window.speechSynthesis.cancel();
                this.currentPlayingIndex = null;
            },
            
            checkSubmissionStatus() {
                const urlParams = new URLSearchParams(window.location.search);
                const studentId = urlParams.get('rid') || '';
                
                if (!studentId) return;
                
                const submissionKey = `test_submitted_${studentId}`;
                const hasSubmitted = localStorage.getItem(submissionKey);
                
                if (hasSubmitted) {
                    const submitTime = localStorage.getItem(`test_submit_time_${studentId}`);
                    const submitScore = localStorage.getItem(`test_submit_score_${studentId}`);
                    
                    vant.Dialog.alert({
                        title: 'æµ‹è¯•å·²å®Œæˆ',
                        message: `ä½ å·²ç»åœ¨ ${new Date(submitTime).toLocaleString()} æäº¤è¿‡æµ‹è¯•äº†ï¼\n\nå¾—åˆ†ï¼š${submitScore}åˆ†\n\næ¯ä½å­¦ç”Ÿåªèƒ½æäº¤ä¸€æ¬¡ã€‚`,
                        confirmButtonText: 'æˆ‘çŸ¥é“äº†',
                        closeOnClickOverlay: false
                    });
                    
                    this.submissionLocked = true;
                }
            },
            
            preventBackNavigation() {
                history.pushState(null, null, location.href);
                window.addEventListener('popstate', () => {
                    if (this.hasSubmitted) {
                        history.pushState(null, null, location.href);
                        vant.Toast.fail('æµ‹è¯•å·²æäº¤ï¼Œæ— æ³•è¿”å›');
                    }
                });
            },
            
            submitTest() {
                if (this.submissionLocked) {
                    vant.Toast.fail('æµ‹è¯•å·²æäº¤ï¼Œæ— æ³•é‡å¤æäº¤');
                    return;
                }
                
                // è®°å½•æœ€åä¸€é¢˜çš„ç”¨æ—¶
                this.recordQuestionTime(this.currentIndex);
                
                const unanswered = this.userAnswers.filter(ans => !ans).length;
                
                if (unanswered > 0) {
                    vant.Dialog.confirm({
                        title: 'æç¤º',
                        message: `è¿˜æœ‰ ${unanswered} é“é¢˜æœªä½œç­”ï¼Œç¡®å®šè¦æäº¤å—ï¼Ÿ`,
                    }).then(() => {
                        this.calculateAndSubmit();
                    }).catch(() => {});
                } else {
                    this.calculateAndSubmit();
                }
            },
            
            calculateAndSubmit() {
    let correct = 0;
    const wrongQuestions = [];
    
    this.questions.forEach((q, i) => {
        const userAnswer = (this.userAnswers[i] || "").trim();
        const correctAnswer = q.answer.trim();
        const isCorrect = userAnswer === correctAnswer || userAnswer.startsWith(correctAnswer);
        
        if (isCorrect) {
            correct++;
        } else {
            wrongQuestions.push(i + 1);
        }
        
        this.questionMetrics[i].isCorrect = isCorrect;
        this.questionMetrics[i].userAnswer = userAnswer;
    });
    
    const score = Math.round((correct / this.questions.length) * 100);
    const behaviorReport = this.generateBehaviorReport(score, correct, wrongQuestions);
    
    const urlParams = new URLSearchParams(window.location.search);
    const studentId = urlParams.get('rid') || '';
    const studentName = sessionStorage.getItem('studentName') || 'æœªçŸ¥å­¦ç”Ÿ';
    
    if (studentId) {
        localStorage.setItem(`test_submitted_${studentId}`, 'true');
        localStorage.setItem(`test_submit_time_${studentId}`, new Date().toISOString());
        localStorage.setItem(`test_submit_score_${studentId}`, score.toString());
    }
    
    this.hasSubmitted = true;
    this.submissionLocked = true;
    
    // è°ƒç”¨APIæäº¤
    this.submitToAPI(studentId, studentName, score, behaviorReport, correct);
},

// æ–°å¢æ–¹æ³•
async submitToAPI(recordId, studentName, score, behaviorData, correctCount) {
    try {
        vant.Toast.loading({
            message: 'æ­£åœ¨æäº¤...',
            forbidClick: true,
            duration: 0
        });
        
        const response = await fetch('/api/submit-test', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                recordId: recordId,
                studentName: studentName,
                score: score,
                behaviorData: behaviorData
            })
        });
        
        const result = await response.json();
        vant.Toast.clear();
        
        if (result.success) {
            // æäº¤æˆåŠŸï¼Œæ˜¾ç¤ºæ¼‚äº®çš„ç»“æœé¡µ
            vant.Dialog.alert({
                title: 'ğŸ‰ æµ‹è¯•å®Œæˆ',
                message: `
                    <div style="text-align: center; padding: 20px;">
                        <div style="font-size: 48px; color: #667eea; margin-bottom: 10px;">
                            ${score}åˆ†
                        </div>
                        <div style="font-size: 16px; color: #666; margin-bottom: 20px;">
                            ç­”å¯¹ ${correctCount} / ${this.questions.length} é¢˜
                        </div>
                        <div style="background: #f0f3ff; padding: 15px; border-radius: 10px; margin-top: 20px;">
                            <div style="font-size: 14px; color: #666; margin-bottom: 5px;">ç”¨æ—¶</div>
                            <div style="font-size: 18px; color: #667eea; font-weight: bold;">
                                ${this.formatTime(this.totalTime)}
                            </div>
                        </div>
                        <div style="margin-top: 20px; font-size: 14px; color: #999;">
                            âœ“ æˆç»©å·²è‡ªåŠ¨ä¿å­˜
                        </div>
                    </div>
                `,
                allowHtml: true,
                confirmButtonText: 'å®Œæˆ',
                closeOnClickOverlay: false
            });
        } else {
            throw new Error(result.error || 'æäº¤å¤±è´¥');
        }
        
    } catch (error) {
        console.error('æäº¤é”™è¯¯:', error);
        vant.Toast.clear();
        
        // å¤±è´¥æ—¶æä¾›å¤‡ç”¨æ–¹æ¡ˆ
        vant.Dialog.confirm({
            title: 'æäº¤å¤±è´¥',
            message: `è‡ªåŠ¨æäº¤å¤±è´¥ï¼Œæ˜¯å¦è·³è½¬åˆ°è¡¨å•æ‰‹åŠ¨æäº¤ï¼Ÿ\n\né”™è¯¯ï¼š${error.message}`,
            confirmButtonText: 'å»æäº¤',
            cancelButtonText: 'å–æ¶ˆ'
        }).then(() => {
            // è·³è½¬åˆ°åŸæ¥çš„é£ä¹¦è¡¨å•
            const behaviorDataJson = JSON.stringify(behaviorData);
            const submitUrl = `https://ycn7fuexi0uc.feishu.cn/share/base/form/shrcndu6DXhs0BJqVoFvkkndKHe?` + 
                `prefill_å­¦ç”Ÿå§“å=${encodeURIComponent(studentName)}` +
                `&prefill_æµ‹è¯•åˆ†æ•°=${score}` +
                `&prefill_å­¦ç”ŸID=${recordId}` +
                `&prefill_å­¦ä¹ è¡Œä¸ºæ•°æ®=${encodeURIComponent(behaviorDataJson)}`;
            
            const isWeChat = /MicroMessenger/i.test(navigator.userAgent);
            if (isWeChat) {
                window.open(submitUrl, '_blank');
            } else {
                window.location.href = submitUrl;
            }
        }).catch(() => {});
    }
}
    }).use(vant).mount('#app');
</script>
</body>
</html>
