<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Ëã±ËØ≠ËÉΩÂäõÊµãËØÑ</title>
    <link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/vant@3/lib/index.css"/>
    <script src="https://fastly.jsdelivr.net/npm/vue@3"></script>
    <script src="https://fastly.jsdelivr.net/npm/vant@3/lib/vant.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Microsoft YaHei', sans-serif;
            padding: 0;
        }
        .app-container { 
            max-width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        /* È°∂ÈÉ®ËøõÂ∫¶Êù° */
        .progress-header {
            background: white;
            padding: 15px 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .progress-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .progress-text {
            font-size: 14px;
            color: #666;
        }
        .progress-text strong {
            color: #667eea;
            font-size: 16px;
        }
        .timer {
            background: #f0f0f0;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
            color: #333;
        }
        .progress-bar-container {
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s ease;
        }
        
        /* È¢òÁõÆÂç°ÁâáÂÆπÂô® */
        .question-container {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding-top: 10px;
        }
        
        /* È¢òÁõÆÂç°Áâá */
        .question-card {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 100%;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            animation: slideIn 0.3s ease-out;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        /* È¢òÁõÆÁ±ªÂûãÊ†áÁ≠æ */
        .question-type {
            display: inline-block;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 14px;
            margin-bottom: 15px;
            font-weight: 500;
        }
        
        /* È¢òÁõÆËØ¥Êòé */
        .question-instruction {
            background: #f8f9fa;
            padding: 12px 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 13px;
            color: #666;
            border-left: 3px solid #667eea;
        }
        
        /* Âê¨ÂäõÊí≠ÊîæÊåâÈíÆ */
        .audio-player {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        .audio-player:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        .audio-player.playing {
            background: linear-gradient(135deg, #f56c6c 0%, #e74c3c 100%);
        }
        .audio-icon {
            font-size: 40px;
            margin-bottom: 10px;
        }
        .audio-text {
            color: white;
            font-size: 16px;
            font-weight: 500;
        }
        .audio-count {
            color: rgba(255,255,255,0.9);
            font-size: 12px;
            margin-top: 5px;
        }
        
        /* ÈòÖËØªÊùêÊñô */
        .reading-passage {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            border-left: 4px solid #667eea;
            line-height: 1.8;
            font-size: 15px;
        }
        
        /* È¢òÁõÆÊñáÊú¨ */
        .question-text {
            font-size: 18px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 20px;
            line-height: 1.6;
        }
        
        /* ÈÄâÈ°πÊ†∑Âºè */
        .options-container {
            margin-bottom: 30px;
        }
        .option-item {
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
        }
        .option-item:hover {
            border-color: #667eea;
            background: #f0f3ff;
        }
        .option-item.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, #f0f3ff 0%, #e8ecff 100%);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
        }
        .option-label {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: white;
            border: 2px solid #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
            flex-shrink: 0;
        }
        .option-item.selected .option-label {
            background: #667eea;
            border-color: #667eea;
            color: white;
        }
        .option-text {
            flex: 1;
            font-size: 16px;
            color: #2c3e50;
        }
        
        /* Â∫ïÈÉ®ÊåâÈíÆ */
        .button-container {
            padding: 20px;
            background: white;
            box-shadow: 0 -2px 8px rgba(0,0,0,0.1);
            display: flex;
            gap: 10px;
        }
        .btn {
            flex: 1;
            height: 50px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        .btn-prev {
            background: #f0f0f0;
            color: #666;
        }
        .btn-prev:hover {
            background: #e0e0e0;
        }
        .btn-prev:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-next {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .btn-next:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        .btn-submit {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }
        
        /* ÂìçÂ∫îÂºè */
        @media (max-width: 768px) {
            .question-card {
                padding: 20px;
                margin-top: 0;
            }
            .question-text {
                font-size: 16px;
            }
            .question-container {
                padding: 10px;
                padding-top: 5px;
            }
            .progress-header {
                padding: 12px 15px;
            }
            .question-type {
                font-size: 13px;
                padding: 6px 15px;
            }
        }
    </style>
</head>
<body>
<div id="app" class="app-container">
    <!-- È°∂ÈÉ®ËøõÂ∫¶Êù° -->
    <div class="progress-header">
        <div class="progress-info">
            <div class="progress-text">
                Á¨¨ <strong>{{ currentIndex + 1 }}</strong> / {{ questions.length }} È¢ò
            </div>
            <div class="timer">‚è±Ô∏è {{ formatTime(totalTime) }}</div>
        </div>
        <div class="progress-bar-container">
            <div class="progress-bar" :style="{ width: progressPercent + '%' }"></div>
        </div>
    </div>
    
    <!-- È¢òÁõÆÂÆπÂô® -->
    <div class="question-container" v-if="questions.length > 0">
        <div class="question-card">
            <!-- È¢òÁõÆÁ±ªÂûãÊ†áÁ≠æ -->
            <div class="question-type">
                {{ getTypeLabel(currentQuestion) }}
            </div>
            
            <!-- È¢òÁõÆËØ¥Êòé -->
            <div class="question-instruction">
                {{ getInstruction(currentQuestion) }}
            </div>
            
            <!-- Âê¨ÂäõÊí≠ÊîæÂô® -->
            <div v-if="currentQuestion.audio_text" 
                 class="audio-player" 
                 :class="{ playing: currentPlayingIndex === currentIndex }"
                 @click="toggleAudio(currentQuestion.audio_text, currentIndex)">
                <div class="audio-icon">
                    {{ currentPlayingIndex === currentIndex ? '‚èπÔ∏è' : 'üîä' }}
                </div>
                <div class="audio-text">
                    {{ currentPlayingIndex === currentIndex ? 'ÁÇπÂáªÂÅúÊ≠¢Êí≠Êîæ' : 'ÁÇπÂáªÊí≠ÊîæÈü≥È¢ë' }}
                </div>
                <div class="audio-count">
                    Â∑≤Êí≠Êîæ {{ questionMetrics[currentIndex].audioPlayCount }} Ê¨°
                </div>
            </div>
            
            <!-- ÈòÖËØªÊùêÊñô -->
            <div v-if="currentQuestion.passage" class="reading-passage">
                {{ currentQuestion.passage }}
            </div>
            
            <!-- È¢òÁõÆÊñáÊú¨ -->
            <div class="question-text">
                {{ currentQuestion.question }}
            </div>
            
            <!-- ÈÄâÈ°π -->
            <div class="options-container">
                <div v-for="(option, index) in currentQuestion.options" 
                     :key="index"
                     class="option-item"
                     :class="{ selected: userAnswers[currentIndex] === option }"
                     @click="selectOption(option)">
                    <div class="option-label">{{ ['A', 'B', 'C', 'D'][index] }}</div>
                    <div class="option-text">{{ option }}</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Âä†ËΩΩÁä∂ÊÄÅ -->
    <van-empty v-else description="ËØïÂç∑Âä†ËΩΩ‰∏≠..." image="search"></van-empty>
    
    <!-- Â∫ïÈÉ®ÊåâÈíÆ -->
    <div class="button-container" v-if="questions.length > 0">
        <button class="btn btn-prev" 
                @click="prevQuestion" 
                :disabled="currentIndex === 0">
            ‚Üê ‰∏ä‰∏ÄÈ¢ò
        </button>
        <button v-if="currentIndex < questions.length - 1" 
                class="btn btn-next" 
                @click="nextQuestion">
            ‰∏ã‰∏ÄÈ¢ò ‚Üí
        </button>
        <button v-else 
                class="btn btn-submit" 
                @click="submitTest">
            Êèê‰∫§ÊµãÈ™å
        </button>
    </div>
</div>

<script>
    const app = Vue.createApp({
        data() { 
            return { 
                questions: [],
                userAnswers: [],
                currentIndex: 0,
                
                testStartTime: null,
                totalTime: 0,
                timerInterval: null,
                questionMetrics: [],
                currentPlayingIndex: null,
                
                hasSubmitted: false,
                submissionLocked: false
            }; 
        },
        computed: {
            currentQuestion() {
                return this.questions[this.currentIndex] || {};
            },
            progressPercent() {
                return ((this.currentIndex + 1) / this.questions.length) * 100;
            }
        },
        created() {
            this.loadQuestions();
            this.checkSubmissionStatus();
        },
        mounted() {
            this.startTimer();
            this.preventBackNavigation();
        },
        beforeUnmount() {
            if (this.timerInterval) clearInterval(this.timerInterval);
            window.speechSynthesis.cancel();
        },
        methods: {
            // Ëé∑ÂèñÈ¢òÂûãÊ†áÁ≠æÔºàÂ§ÑÁêÜÁº∫Â§±ÁöÑÊÉÖÂÜµÔºâ
            getTypeLabel(question) {
                if (question.typeLabel) {
                    return question.typeLabel;
                }
                // Ê†πÊçÆÈ¢òÁõÆÁ±ªÂûãÊé®Êñ≠
                if (question.audio_text) return 'üéß Âê¨ÂäõÁêÜËß£ Listening';
                if (question.passage) return 'üìñ ÈòÖËØªÁêÜËß£ Reading';
                if (question.options && question.options.length === 2) return '‚úÖ Âà§Êñ≠È¢ò True or False';
                if (question.questionType === 'ËØçÊ±á') return 'üìö ËØçÊ±áÈ¢ò Vocabulary';
                if (question.questionType === 'ËØ≠Ê≥ï') return '‚úèÔ∏è ËØ≠Ê≥ïÂ°´Á©∫ Grammar';
                if (question.questionType === 'Áü≠Âè•') return 'üìù Áü≠Âè•ÁêÜËß£ Sentence';
                return 'üìù ÈÄâÊã©È¢ò Question';
            },
            
            // Ëé∑ÂèñÊìç‰ΩúËØ¥ÊòéÔºàÂ§ÑÁêÜÁº∫Â§±ÁöÑÊÉÖÂÜµÔºâ
            getInstruction(question) {
                if (question.instruction) {
                    return question.instruction;
                }
                // Ê†πÊçÆÈ¢òÁõÆÁ±ªÂûãÊé®Êñ≠
                if (question.audio_text) return '‰ªîÁªÜÂê¨Èü≥È¢ëÔºåÁÑ∂ÂêéÈÄâÊã©Ê≠£Á°ÆÁ≠îÊ°à„ÄÇÂèØ‰ª•ÈáçÂ§çÊí≠Êîæ„ÄÇ';
                if (question.passage) return '‰ªîÁªÜÈòÖËØªÁü≠ÊñáÔºåÁÑ∂ÂêéÂõûÁ≠îÈóÆÈ¢ò„ÄÇ';
                if (question.options && question.options.length === 2) return 'Âà§Êñ≠‰∏ãÈù¢ÁöÑÂè•Â≠êÊòØÂØπ(True)ËøòÊòØÈîô(False)„ÄÇ';
                if (question.questionType === 'ËØçÊ±á') return 'ÈÄâÊã©Ê≠£Á°ÆÁöÑÂçïËØçÊàñËØç‰πâ„ÄÇ';
                if (question.questionType === 'ËØ≠Ê≥ï') return 'ÈÄâÊã©Ê≠£Á°ÆÁöÑÂçïËØçÂ°´ÂÖ•Á©∫Ê†º„ÄÇ';
                if (question.questionType === 'Áü≠Âè•') return 'ËØªÂè•Â≠êÔºåÈÄâÊã©Ê≠£Á°ÆÁöÑ‰∏≠ÊñáÊÑèÊÄùÊàñÁ≠îÊ°à„ÄÇ';
                return 'ËØ∑ÈÄâÊã©Ê≠£Á°ÆÁöÑÁ≠îÊ°à„ÄÇ';
            },
            
            async loadQuestions() {
                const urlParams = new URLSearchParams(window.location.search);
                const recordId = urlParams.get('rid');
                
                if (!recordId) {
                    vant.Toast.fail("Áº∫Â∞ëËÆ∞ÂΩïIDÂèÇÊï∞");
                    return;
                }
                
                try {
                    vant.Toast.loading({
                        message: 'Âä†ËΩΩÈ¢òÁõÆ‰∏≠...',
                        forbidClick: true,
                        duration: 0
                    });
                    
                    const apiUrl = '/api/get-test-data';
                    const response = await fetch(`${apiUrl}?rid=${recordId}`);
                    
                    if (!response.ok) {
                        throw new Error('Âä†ËΩΩÈ¢òÁõÆÂ§±Ë¥•');
                    }
                    
                    const result = await response.json();
                    
                    vant.Toast.clear();
                    
                    if (!result.success) {
                        throw new Error(result.error || 'Êï∞ÊçÆÂä†ËΩΩÂ§±Ë¥•');
                    }
                    
                    const { studentName, questions } = result.data;
                    
                    if (questions && questions.length > 0) {
                        this.questions = questions;
                        this.userAnswers = new Array(this.questions.length).fill('');
                        this.initQuestionMetrics();
                        this.questionMetrics[0].startTime = Date.now();
                        sessionStorage.setItem('studentName', studentName);
                        vant.Toast.success('È¢òÁõÆÂä†ËΩΩÊàêÂäü');
                    } else {
                        throw new Error('È¢òÁõÆÊï∞ÊçÆ‰∏∫Á©∫');
                    }
                    
                } catch (error) { 
                    console.error('È¢òÁõÆÂä†ËΩΩÈîôËØØ:', error);
                    vant.Toast.clear();
                    vant.Toast.fail('È¢òÁõÆÂä†ËΩΩÂ§±Ë¥•: ' + error.message);
                }
            },
            
            initQuestionMetrics() {
                this.questionMetrics = this.questions.map((q, index) => ({
                    questionIndex: index + 1,
                    startTime: null,
                    timeSpent: 0,
                    isCorrect: false,
                    userAnswer: '',
                    correctAnswer: q.answer,
                    changeCount: 0,
                    audioPlayCount: 0,
                    questionType: q.questionType || 'ÂÖ∂‰ªñ',
                    questionText: q.question || q.audio_text || ''
                }));
            },
            
            startTimer() {
                this.testStartTime = Date.now();
                this.timerInterval = setInterval(() => {
                    this.totalTime = Math.floor((Date.now() - this.testStartTime) / 1000);
                }, 1000);
            },
            
            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            },
            
            selectOption(option) {
                if (this.submissionLocked) return;
                
                const metric = this.questionMetrics[this.currentIndex];
                
                if (metric.userAnswer && metric.userAnswer !== option) {
                    metric.changeCount++;
                }
                
                metric.userAnswer = option;
                this.userAnswers[this.currentIndex] = option;
            },
            
            nextQuestion() {
                this.recordQuestionTime(this.currentIndex);
                
                if (this.currentIndex < this.questions.length - 1) {
                    this.currentIndex++;
                    
                    const metric = this.questionMetrics[this.currentIndex];
                    if (!metric.startTime) {
                        metric.startTime = Date.now();
                    }
                    
                    this.stopAudio();
                }
            },
            
            prevQuestion() {
                this.recordQuestionTime(this.currentIndex);
                
                if (this.currentIndex > 0) {
                    this.currentIndex--;
                    this.stopAudio();
                }
            },
            
            recordQuestionTime(index) {
                const metric = this.questionMetrics[index];
                if (metric.startTime) {
                    metric.timeSpent = (Date.now() - metric.startTime) / 1000;
                }
            },
            
            toggleAudio(text, index) {
                if (this.currentPlayingIndex === index) {
                    this.stopAudio();
                } else {
                    this.playAudio(text, index);
                }
            },
            
            playAudio(text, index) {
                this.questionMetrics[index].audioPlayCount++;
                window.speechSynthesis.cancel();
                
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'en-US';
                utterance.rate = 0.9;
                
                this.currentPlayingIndex = index;
                
                utterance.onend = () => {
                    this.currentPlayingIndex = null;
                };
                
                utterance.onerror = () => {
                    this.currentPlayingIndex = null;
                };
                
                window.speechSynthesis.speak(utterance);
            },
            
            stopAudio() {
                window.speechSynthesis.cancel();
                this.currentPlayingIndex = null;
            },
            
            checkSubmissionStatus() {
                const urlParams = new URLSearchParams(window.location.search);
                const studentId = urlParams.get('rid') || '';
                
                if (!studentId) return;
                
                const submissionKey = `test_submitted_${studentId}`;
                const hasSubmitted = localStorage.getItem(submissionKey);
                
                if (hasSubmitted) {
                    const submitTime = localStorage.getItem(`test_submit_time_${studentId}`);
                    const submitScore = localStorage.getItem(`test_submit_score_${studentId}`);
                    
                    vant.Dialog.alert({
                        title: 'ÊµãËØïÂ∑≤ÂÆåÊàê',
                        message: `‰Ω†Â∑≤ÁªèÂú® ${new Date(submitTime).toLocaleString()} Êèê‰∫§ËøáÊµãËØï‰∫ÜÔºÅ\n\nÂæóÂàÜÔºö${submitScore}ÂàÜ\n\nÊØè‰ΩçÂ≠¶ÁîüÂè™ËÉΩÊèê‰∫§‰∏ÄÊ¨°„ÄÇ`,
                        confirmButtonText: 'ÊàëÁü•ÈÅì‰∫Ü',
                        closeOnClickOverlay: false
                    });
                    
                    this.submissionLocked = true;
                }
            },
            
            preventBackNavigation() {
                history.pushState(null, null, location.href);
                window.addEventListener('popstate', () => {
                    if (this.hasSubmitted) {
                        history.pushState(null, null, location.href);
                        vant.Toast.fail('ÊµãËØïÂ∑≤Êèê‰∫§ÔºåÊó†Ê≥ïËøîÂõû');
                    }
                });
            },
            
            submitTest() {
                if (this.submissionLocked) {
                    vant.Toast.fail('ÊµãËØïÂ∑≤Êèê‰∫§ÔºåÊó†Ê≥ïÈáçÂ§çÊèê‰∫§');
                    return;
                }
                
                this.recordQuestionTime(this.currentIndex);
                
                const unanswered = this.userAnswers.filter(ans => !ans).length;
                
                if (unanswered > 0) {
                    vant.Dialog.confirm({
                        title: 'ÊèêÁ§∫',
                        message: `ËøòÊúâ ${unanswered} ÈÅìÈ¢òÊú™‰ΩúÁ≠îÔºåÁ°ÆÂÆöË¶ÅÊèê‰∫§ÂêóÔºü`,
                    }).then(() => {
                        this.calculateAndSubmit();
                    }).catch(() => {});
                } else {
                    this.calculateAndSubmit();
                }
            },
            
            calculateAndSubmit() {
                let correct = 0;
                const wrongQuestions = [];
                
                this.questions.forEach((q, i) => {
                    const userAnswer = (this.userAnswers[i] || "").trim();
                    const correctAnswer = q.answer.trim();
                    
                    const isCorrect = userAnswer === correctAnswer || userAnswer.startsWith(correctAnswer);
                    
                    if (isCorrect) {
                        correct++;
                    } else {
                        wrongQuestions.push(i + 1);
                    }
                    
                    this.questionMetrics[i].isCorrect = isCorrect;
                    this.questionMetrics[i].userAnswer = userAnswer;
                });
                
                const score = Math.round((correct / this.questions.length) * 100);
                const behaviorReport = this.generateBehaviorReport(score, correct, wrongQuestions);
                
                const urlParams = new URLSearchParams(window.location.search);
                const studentId = urlParams.get('rid') || '';
                const studentName = sessionStorage.getItem('studentName') || 'Êú™Áü•Â≠¶Áîü';
                
                if (studentId) {
                    localStorage.setItem(`test_submitted_${studentId}`, 'true');
                    localStorage.setItem(`test_submit_time_${studentId}`, new Date().toISOString());
                    localStorage.setItem(`test_submit_score_${studentId}`, score.toString());
                }
                
                this.hasSubmitted = true;
                this.submissionLocked = true;
                
                // Ë∞ÉÁî®APIËá™Âä®Êèê‰∫§
                this.submitToAPI(studentId, studentName, score, behaviorReport, correct);
            },
            
            // Ëá™Âä®Êèê‰∫§Âà∞È£û‰π¶API
            async submitToAPI(recordId, studentName, score, behaviorData, correctCount) {
                try {
                    vant.Toast.loading({
                        message: 'Ê≠£Âú®Êèê‰∫§ÊàêÁª©...',
                        forbidClick: true,
                        duration: 0
                    });
                    
                    const response = await fetch('/api/submit-test', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            recordId: recordId,
                            studentName: studentName,
                            score: score,
                            behaviorData: behaviorData
                        })
                    });
                    
                    const result = await response.json();
                    vant.Toast.clear();
                    
                    if (result.success) {
                        // Êèê‰∫§ÊàêÂäüÔºåÊòæÁ§∫ÊàêÁª©
                        vant.Dialog.alert({
                            title: 'üéâ ÊµãËØïÂÆåÊàê',
                            message: `
                                <div style="text-align: center; padding: 20px;">
                                    <div style="font-size: 48px; color: #667eea; margin-bottom: 10px; font-weight: bold;">
                                        ${score}ÂàÜ
                                    </div>
                                    <div style="font-size: 16px; color: #666; margin-bottom: 20px;">
                                        Á≠îÂØπ ${correctCount} / ${this.questions.length} È¢ò
                                    </div>
                                    <div style="background: #f0f3ff; padding: 15px; border-radius: 10px; margin-top: 20px;">
                                        <div style="font-size: 14px; color: #666; margin-bottom: 5px;">Áî®Êó∂</div>
                                        <div style="font-size: 18px; color: #667eea; font-weight: bold;">
                                            ${this.formatTime(this.totalTime)}
                                        </div>
                                    </div>
                                    <div style="margin-top: 20px; font-size: 14px; color: #999;">
                                        ‚úì ÊàêÁª©Â∑≤Ëá™Âä®‰øùÂ≠ò
                                    </div>
                                </div>
                            `,
                            allowHtml: true,
                            confirmButtonText: 'ÂÆåÊàê',
                            closeOnClickOverlay: false
                        });
                    } else {
                        throw new Error(result.error || 'Êèê‰∫§Â§±Ë¥•');
                    }
                    
                } catch (error) {
                    console.error('Êèê‰∫§ÈîôËØØ:', error);
                    vant.Toast.clear();
                    
                    // Â§±Ë¥•Êó∂ÊòæÁ§∫ÈîôËØØ
                    vant.Dialog.alert({
                        title: 'Êèê‰∫§Â§±Ë¥•',
                        message: `Ëá™Âä®Êèê‰∫§Â§±Ë¥•Ôºå‰ΩÜÊàêÁª©Â∑≤‰øùÂ≠òÂú®Êú¨Âú∞„ÄÇ\n\nÈîôËØØÔºö${error.message}\n\nËØ∑ËÅîÁ≥ªËÄÅÂ∏àËÆ∞ÂΩïÊàêÁª©„ÄÇ`,
                        confirmButtonText: 'Áü•ÈÅì‰∫Ü'
                    });
                }
            },
            
            generateBehaviorReport(score, correctCount, wrongQuestions) {
                const typeStats = {};
                this.questionMetrics.forEach(metric => {
                    if (!typeStats[metric.questionType]) {
                        typeStats[metric.questionType] = {
                            total: 0,
                            correct: 0,
                            avgTime: 0,
                            totalTime: 0
                        };
                    }
                    typeStats[metric.questionType].total++;
                    if (metric.isCorrect) {
                        typeStats[metric.questionType].correct++;
                    }
                    typeStats[metric.questionType].totalTime += metric.timeSpent;
                });
                
                Object.keys(typeStats).forEach(type => {
                    typeStats[type].avgTime = Math.round(typeStats[type].totalTime / typeStats[type].total);
                    typeStats[type].accuracy = Math.round((typeStats[type].correct / typeStats[type].total) * 100);
                });
                
                const sortedByTime = [...this.questionMetrics].sort((a, b) => b.timeSpent - a.timeSpent);
                
                return {
                    score: score,
                    correctCount: correctCount,
                    totalQuestions: this.questions.length,
                    totalTime: this.totalTime,
                    avgTimePerQuestion: Math.round(this.totalTime / this.questions.length),
                    wrongQuestions: wrongQuestions,
                    wrongCount: wrongQuestions.length,
                    questionDetails: this.questionMetrics.map(m => ({
                        questionIndex: m.questionIndex,
                        questionType: m.questionType,
                        isCorrect: m.isCorrect,
                        timeSpent: Math.round(m.timeSpent),
                        userAnswer: m.userAnswer,
                        correctAnswer: m.correctAnswer,
                        changeCount: m.changeCount,
                        audioPlayCount: m.audioPlayCount
                    })),
                    typeStatistics: typeStats,
                    patterns: {
                        fastestQuestion: sortedByTime[sortedByTime.length - 1]?.questionIndex || 0,
                        slowestQuestion: sortedByTime[0]?.questionIndex || 0,
                        totalChanges: this.questionMetrics.reduce((sum, m) => sum + m.changeCount, 0),
                        totalAudioPlays: this.questionMetrics.reduce((sum, m) => sum + m.audioPlayCount, 0)
                    },
                    submittedAt: new Date().toISOString()
                };
            }
        }
    }).use(vant).mount('#app');
</script>
</body>
</html>
