<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI è‹±è¯­èƒ½åŠ›æµ‹è¯„</title>
    <link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/vant@3/lib/index.css"/>
    <script src="https://fastly.jsdelivr.net/npm/vue@3"></script>
    <script src="https://fastly.jsdelivr.net/npm/vant@3/lib/vant.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Microsoft YaHei', sans-serif;
            padding: 0;
        }
        .app-container { 
            max-width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        /* é¡¶éƒ¨è¿›åº¦æ¡ */
        .progress-header {
            background: white;
            padding: 15px 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .progress-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .progress-text {
            font-size: 14px;
            color: #666;
        }
        .progress-text strong {
            color: #667eea;
            font-size: 16px;
        }
        .timer {
            background: #f0f0f0;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
            color: #333;
        }
        .progress-bar-container {
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s ease;
        }
        
        /* é’ˆå¯¹æˆç»©ç»“æœå®¹å™¨çš„ä¼˜åŒ– */
.result-card {
    background: white;
    border-radius: 20px;
    padding: 25px;
    margin: 20px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    /* è§£å†³æ˜¾ç¤ºä¸å…¨çš„å…³é”®ï¼šå…è®¸å®¹å™¨å†…éƒ¨æ»šåŠ¨ */
    max-height: 80vh; 
    overflow-y: auto;
}

/* ç¾åŒ–åˆ†æ•°æ˜¾ç¤º */
.score-circle {
    width: 120px;
    height: 120px;
    border-radius: 50%;
    border: 8px solid #f0f0f0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    margin: 0 auto 20px;
    background: #fff;
}

.score-number {
    font-size: 36px;
    font-weight: bold;
    color: #7232dd;
}
        
        /* é¢˜ç›®å¡ç‰‡å®¹å™¨ */
        .question-container {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding-top: 10px;
        }
        
        /* é¢˜ç›®å¡ç‰‡ */
        .question-card {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 100%;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            animation: slideIn 0.3s ease-out;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        /* é¢˜ç›®ç±»å‹æ ‡ç­¾ */
        .question-type {
            display: inline-block;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 14px;
            margin-bottom: 15px;
            font-weight: 500;
        }
        
        /* é¢˜ç›®è¯´æ˜ */
        .question-instruction {
            background: #f8f9fa;
            padding: 12px 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 13px;
            color: #666;
            border-left: 3px solid #667eea;
        }
        
        /* å¬åŠ›æ’­æ”¾æŒ‰é’® */
        .audio-player {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        .audio-player:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        .audio-player.playing {
            background: linear-gradient(135deg, #f56c6c 0%, #e74c3c 100%);
        }
        .audio-icon {
            font-size: 40px;
            margin-bottom: 10px;
        }
        .audio-text {
            color: white;
            font-size: 16px;
            font-weight: 500;
        }
        .audio-count {
            color: rgba(255,255,255,0.9);
            font-size: 12px;
            margin-top: 5px;
        }
        
        /* é˜…è¯»ææ–™ */
        .reading-passage {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            border-left: 4px solid #667eea;
            line-height: 1.8;
            font-size: 15px;
        }
        
        /* é¢˜ç›®æ–‡æœ¬ */
        .question-text {
            font-size: 18px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 20px;
            line-height: 1.6;
        }
        
        /* é€‰é¡¹æ ·å¼ */
        .options-container {
            margin-bottom: 30px;
        }
        .option-item {
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
        }
        .option-item:hover {
            border-color: #667eea;
            background: #f0f3ff;
        }
        .option-item.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, #f0f3ff 0%, #e8ecff 100%);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
        }
        .option-label {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: white;
            border: 2px solid #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
            flex-shrink: 0;
        }
        .option-item.selected .option-label {
            background: #667eea;
            border-color: #667eea;
            color: white;
        }
        .option-text {
            flex: 1;
            font-size: 16px;
            color: #2c3e50;
        }
        
        /* åº•éƒ¨æŒ‰é’® */
        .button-container {
            padding: 20px;
            background: white;
            box-shadow: 0 -2px 8px rgba(0,0,0,0.1);
            display: flex;
            gap: 10px;
        }
        .btn {
            flex: 1;
            height: 50px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        .btn-prev {
            background: #f0f0f0;
            color: #666;
        }
        .btn-prev:hover {
            background: #e0e0e0;
        }
        .btn-prev:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-next {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .btn-next:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        .btn-submit {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }
        
        /* å“åº”å¼ */
        @media (max-width: 768px) {
            .question-card {
                padding: 20px;
                margin-top: 0;
            }
            .question-text {
                font-size: 16px;
            }
            .question-container {
                padding: 10px;
                padding-top: 5px;
            }
            .progress-header {
                padding: 12px 15px;
            }
            .question-type {
                font-size: 13px;
                padding: 6px 15px;
            }
        }
    </style>
</head>
<body>
<div id="app" class="app-container">
    <!-- é¡¶éƒ¨è¿›åº¦æ¡ -->
    <div class="progress-header">
        <div class="progress-info">
            <div class="progress-text">
                ç¬¬ <strong>{{ currentIndex + 1 }}</strong> / {{ questions.length }} é¢˜
            </div>
            <div class="timer">â±ï¸ {{ formatTime(totalTime) }}</div>
        </div>
        <div class="progress-bar-container">
            <div class="progress-bar" :style="{ width: progressPercent + '%' }"></div>
        </div>
    </div>
    
    <!-- é¢˜ç›®å®¹å™¨ -->
    <div class="question-container" v-if="questions.length > 0">
        <div class="question-card">
            <!-- é¢˜ç›®ç±»å‹æ ‡ç­¾ -->
            <div class="question-type">
                {{ getTypeLabel(currentQuestion) }}
            </div>
            
            <!-- é¢˜ç›®è¯´æ˜ -->
            <div class="question-instruction">
                {{ getInstruction(currentQuestion) }}
            </div>
            
            <!-- å¬åŠ›æ’­æ”¾å™¨ -->
            <div v-if="currentQuestion.audio_text" 
                 class="audio-player" 
                 :class="{ playing: currentPlayingIndex === currentIndex }"
                 @click="toggleAudio(currentQuestion.audio_text, currentIndex)">
                <div class="audio-icon">
                    {{ currentPlayingIndex === currentIndex ? 'â¹ï¸' : 'ğŸ”Š' }}
                </div>
                <div class="audio-text">
                    {{ currentPlayingIndex === currentIndex ? 'ç‚¹å‡»åœæ­¢æ’­æ”¾' : 'ç‚¹å‡»æ’­æ”¾éŸ³é¢‘' }}
                </div>
                <div class="audio-count">
                    å·²æ’­æ”¾ {{ questionMetrics[currentIndex].audioPlayCount }} æ¬¡
                </div>
            </div>
            
            <!-- é˜…è¯»ææ–™ -->
            <div v-if="currentQuestion.passage" class="reading-passage">
                {{ currentQuestion.passage }}
            </div>
            
            <!-- é¢˜ç›®æ–‡æœ¬ -->
            <div class="question-text">
                {{ currentQuestion.question }}
            </div>
            
            <!-- é€‰é¡¹ -->
            <div class="options-container">
                <div v-for="(option, index) in currentQuestion.options" 
                     :key="index"
                     class="option-item"
                     :class="{ selected: userAnswers[currentIndex] === option }"
                     @click="selectOption(option)">
                    <div class="option-label">{{ ['A', 'B', 'C', 'D'][index] }}</div>
                    <div class="option-text">{{ option }}</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- åŠ è½½çŠ¶æ€ -->
    <van-empty v-else description="è¯•å·åŠ è½½ä¸­..." image="search"></van-empty>
    
    <!-- åº•éƒ¨æŒ‰é’® -->
    <div class="action-footer">
    <van-button v-if="currentIndex > 0" @click="prevQuestion" round block>ä¸Šä¸€é¢˜</van-button>
    
    <van-button v-if="currentIndex < questions.length - 1" @click="nextQuestion" type="primary" round block>ä¸‹ä¸€é¢˜</van-button>
    
    <van-button v-if="currentIndex === questions.length - 1" @click="submitResults" type="danger" round block>æäº¤æµ‹è¯•</van-button>
</div>

<script>
    const app = Vue.createApp({
        data() { 
            return { 
                questions: [],
                userAnswers: [],
                currentIndex: 0,
                
                testStartTime: null,
                totalTime: 0,
                timerInterval: null,
                questionMetrics: [],
                currentPlayingIndex: null,
                
                hasSubmitted: false,
                submissionLocked: false
            }; 
        },
        computed: {
            currentQuestion() {
                return this.questions[this.currentIndex] || {};
            },
            progressPercent() {
                return ((this.currentIndex + 1) / this.questions.length) * 100;
            }
        },
        created() {
            this.loadQuestions();
            this.checkSubmissionStatus();
        },
        mounted() {
            this.startTimer();
            this.preventBackNavigation();
        },
        beforeUnmount() {
            if (this.timerInterval) clearInterval(this.timerInterval);
            window.speechSynthesis.cancel();
        },
        methods: {
            // è·å–é¢˜å‹æ ‡ç­¾ï¼ˆå¤„ç†ç¼ºå¤±çš„æƒ…å†µï¼‰
            getTypeLabel(question) {
                if (question.typeLabel) {
                    return question.typeLabel;
                }
                // æ ¹æ®é¢˜ç›®ç±»å‹æ¨æ–­
                if (question.audio_text) return 'ğŸ§ å¬åŠ›ç†è§£ Listening';
                if (question.passage) return 'ğŸ“– é˜…è¯»ç†è§£ Reading';
                if (question.options && question.options.length === 2) return 'âœ… åˆ¤æ–­é¢˜ True or False';
                if (question.questionType === 'è¯æ±‡') return 'ğŸ“š è¯æ±‡é¢˜ Vocabulary';
                if (question.questionType === 'è¯­æ³•') return 'âœï¸ è¯­æ³•å¡«ç©º Grammar';
                if (question.questionType === 'çŸ­å¥') return 'ğŸ“ çŸ­å¥ç†è§£ Sentence';
                return 'ğŸ“ é€‰æ‹©é¢˜ Question';
            },
            
            // è·å–æ“ä½œè¯´æ˜ï¼ˆå¤„ç†ç¼ºå¤±çš„æƒ…å†µï¼‰
            getInstruction(question) {
                if (question.instruction) {
                    return question.instruction;
                }
                // æ ¹æ®é¢˜ç›®ç±»å‹æ¨æ–­
                if (question.audio_text) return 'ä»”ç»†å¬éŸ³é¢‘ï¼Œç„¶åé€‰æ‹©æ­£ç¡®ç­”æ¡ˆã€‚å¯ä»¥é‡å¤æ’­æ”¾ã€‚';
                if (question.passage) return 'ä»”ç»†é˜…è¯»çŸ­æ–‡ï¼Œç„¶åå›ç­”é—®é¢˜ã€‚';
                if (question.options && question.options.length === 2) return 'åˆ¤æ–­ä¸‹é¢çš„å¥å­æ˜¯å¯¹(True)è¿˜æ˜¯é”™(False)ã€‚';
                if (question.questionType === 'è¯æ±‡') return 'é€‰æ‹©æ­£ç¡®çš„å•è¯æˆ–è¯ä¹‰ã€‚';
                if (question.questionType === 'è¯­æ³•') return 'é€‰æ‹©æ­£ç¡®çš„å•è¯å¡«å…¥ç©ºæ ¼ã€‚';
                if (question.questionType === 'çŸ­å¥') return 'è¯»å¥å­ï¼Œé€‰æ‹©æ­£ç¡®çš„ä¸­æ–‡æ„æ€æˆ–ç­”æ¡ˆã€‚';
                return 'è¯·é€‰æ‹©æ­£ç¡®çš„ç­”æ¡ˆã€‚';
            },
            
            async loadQuestions() {
                const urlParams = new URLSearchParams(window.location.search);
                const recordId = urlParams.get('rid');
                
                if (!recordId) {
                    vant.Toast.fail("ç¼ºå°‘è®°å½•IDå‚æ•°");
                    return;
                }
                
                try {
                    vant.Toast.loading({
                        message: 'åŠ è½½é¢˜ç›®ä¸­...',
                        forbidClick: true,
                        duration: 0
                    });
                    
                    const apiUrl = '/api/get-test-data';
                    const response = await fetch(`${apiUrl}?rid=${recordId}`);
                    
                    if (!response.ok) {
                        throw new Error('åŠ è½½é¢˜ç›®å¤±è´¥');
                    }
                    
                    const result = await response.json();
                    
                    vant.Toast.clear();
                    
                    if (!result.success) {
                        throw new Error(result.error || 'æ•°æ®åŠ è½½å¤±è´¥');
                    }
                    
                    const { studentName, questions } = result.data;
                    
                    if (questions && questions.length > 0) {
                        this.questions = questions;
                        this.userAnswers = new Array(this.questions.length).fill('');
                        this.initQuestionMetrics();
                        this.questionMetrics[0].startTime = Date.now();
                        sessionStorage.setItem('studentName', studentName);
                        vant.Toast.success('é¢˜ç›®åŠ è½½æˆåŠŸ');
                    } else {
                        throw new Error('é¢˜ç›®æ•°æ®ä¸ºç©º');
                    }
                    
                } catch (error) { 
                    console.error('é¢˜ç›®åŠ è½½é”™è¯¯:', error);
                    vant.Toast.clear();
                    vant.Toast.fail('é¢˜ç›®åŠ è½½å¤±è´¥: ' + error.message);
                }
            },
            
            initQuestionMetrics() {
                this.questionMetrics = this.questions.map((q, index) => ({
                    questionIndex: index + 1,
                    startTime: null,
                    timeSpent: 0,
                    isCorrect: false,
                    userAnswer: '',
                    correctAnswer: q.answer,
                    changeCount: 0,
                    audioPlayCount: 0,
                    questionType: q.questionType || 'å…¶ä»–',
                    questionText: q.question || q.audio_text || ''
                }));
            },
            
            startTimer() {
                this.testStartTime = Date.now();
                this.timerInterval = setInterval(() => {
                    this.totalTime = Math.floor((Date.now() - this.testStartTime) / 1000);
                }, 1000);
            },
            
            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            },
            
            selectOption(option) {
                if (this.submissionLocked) return;
                
                const metric = this.questionMetrics[this.currentIndex];
                
                if (metric.userAnswer && metric.userAnswer !== option) {
                    metric.changeCount++;
                }
                
                metric.userAnswer = option;
                this.userAnswers[this.currentIndex] = option;
            },
            
            nextQuestion() {
                this.recordQuestionTime(this.currentIndex);
                
                if (this.currentIndex < this.questions.length - 1) {
                    this.currentIndex++;
                    
                    const metric = this.questionMetrics[this.currentIndex];
                    if (!metric.startTime) {
                        metric.startTime = Date.now();
                    }
                    
                    this.stopAudio();
                }
            },
            
            prevQuestion() {
                this.recordQuestionTime(this.currentIndex);
                
                if (this.currentIndex > 0) {
                    this.currentIndex--;
                    this.stopAudio();
                }
            },
            
            recordQuestionTime(index) {
                const metric = this.questionMetrics[index];
                if (metric.startTime) {
                    metric.timeSpent = (Date.now() - metric.startTime) / 1000;
                }
            },
            
            toggleAudio(text, index) {
                if (this.currentPlayingIndex === index) {
                    this.stopAudio();
                } else {
                    this.playAudio(text, index);
                }
            },
            
            playAudio(text, index) {
                this.questionMetrics[index].audioPlayCount++;
                window.speechSynthesis.cancel();
                
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'en-US';
                utterance.rate = 0.9;
                
                this.currentPlayingIndex = index;
                
                utterance.onend = () => {
                    this.currentPlayingIndex = null;
                };
                
                utterance.onerror = () => {
                    this.currentPlayingIndex = null;
                };
                
                window.speechSynthesis.speak(utterance);
            },
            
            stopAudio() {
                window.speechSynthesis.cancel();
                this.currentPlayingIndex = null;
            },
            
            checkSubmissionStatus() {
                const urlParams = new URLSearchParams(window.location.search);
                const studentId = urlParams.get('rid') || '';
                
                if (!studentId) return;
                
                const submissionKey = `test_submitted_${studentId}`;
                const hasSubmitted = localStorage.getItem(submissionKey);
                
                if (hasSubmitted) {
                    const submitTime = localStorage.getItem(`test_submit_time_${studentId}`);
                    const submitScore = localStorage.getItem(`test_submit_score_${studentId}`);
                    
                    vant.Dialog.alert({
                        title: 'æµ‹è¯•å·²å®Œæˆ',
                        message: `ä½ å·²ç»åœ¨ ${new Date(submitTime).toLocaleString()} æäº¤è¿‡æµ‹è¯•äº†ï¼\n\nå¾—åˆ†ï¼š${submitScore}åˆ†\n\næ¯ä½å­¦ç”Ÿåªèƒ½æäº¤ä¸€æ¬¡ã€‚`,
                        confirmButtonText: 'æˆ‘çŸ¥é“äº†',
                        closeOnClickOverlay: false
                    });
                    
                    this.submissionLocked = true;
                }
            },
            
            preventBackNavigation() {
                history.pushState(null, null, location.href);
                window.addEventListener('popstate', () => {
                    if (this.hasSubmitted) {
                        history.pushState(null, null, location.href);
                        vant.Toast.fail('æµ‹è¯•å·²æäº¤ï¼Œæ— æ³•è¿”å›');
                    }
                });
            },
            
            submitTest() {
                if (this.submissionLocked) {
                    vant.Toast.fail('æµ‹è¯•å·²æäº¤ï¼Œæ— æ³•é‡å¤æäº¤');
                    return;
                }
                
                this.recordQuestionTime(this.currentIndex);
                
                const unanswered = this.userAnswers.filter(ans => !ans).length;
                
                if (unanswered > 0) {
                    vant.Dialog.confirm({
                        title: 'æç¤º',
                        message: `è¿˜æœ‰ ${unanswered} é“é¢˜æœªä½œç­”ï¼Œç¡®å®šè¦æäº¤å—ï¼Ÿ`,
                    }).then(() => {
                        this.calculateAndSubmit();
                    }).catch(() => {});
                } else {
                    this.calculateAndSubmit();
                }
            },
            
            calculateAndSubmit() {
                let correct = 0;
                const wrongQuestions = [];
                
                this.questions.forEach((q, i) => {
                    const userAnswer = (this.userAnswers[i] || "").trim();
                    const correctAnswer = q.answer.trim();
                    
                    const isCorrect = userAnswer === correctAnswer || userAnswer.startsWith(correctAnswer);
                    
                    if (isCorrect) {
                        correct++;
                    } else {
                        wrongQuestions.push(i + 1);
                    }
                    
                    this.questionMetrics[i].isCorrect = isCorrect;
                    this.questionMetrics[i].userAnswer = userAnswer;
                });
                
                const score = Math.round((correct / this.questions.length) * 100);
                const behaviorReport = this.generateBehaviorReport(score, correct, wrongQuestions);
                
                const urlParams = new URLSearchParams(window.location.search);
                const studentId = urlParams.get('rid') || '';
                const studentName = sessionStorage.getItem('studentName') || 'æœªçŸ¥å­¦ç”Ÿ';
                
                if (studentId) {
                    localStorage.setItem(`test_submitted_${studentId}`, 'true');
                    localStorage.setItem(`test_submit_time_${studentId}`, new Date().toISOString());
                    localStorage.setItem(`test_submit_score_${studentId}`, score.toString());
                }
                
                this.hasSubmitted = true;
                this.submissionLocked = true;
                
                // è°ƒç”¨APIè‡ªåŠ¨æäº¤
                this.submitToAPI(studentId, studentName, score, behaviorReport, correct);
            },
            
            // è‡ªåŠ¨æäº¤åˆ°é£ä¹¦API
            async submitToAPI(recordId, studentName, score, behaviorData, correctCount) {
                try {
                    vant.Toast.loading({
                        message: 'æ­£åœ¨æäº¤æˆç»©...',
                        forbidClick: true,
                        duration: 0
                    });
                    
                    const response = await fetch('/api/submit-test', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            recordId: recordId,
                            studentName: studentName,
                            score: score,
                            behaviorData: behaviorData
                        })
                    });
                    
                    const result = await response.json();
                    vant.Toast.clear();
                    
                    if (result.success) {
                        // æäº¤æˆåŠŸï¼Œæ˜¾ç¤ºæˆç»©
                        vant.Dialog.alert({
                            title: 'ğŸ‰ æµ‹è¯•å®Œæˆ',
                            message: `
                                <div style="text-align: center; padding: 20px;">
                                    <div style="font-size: 48px; color: #667eea; margin-bottom: 10px; font-weight: bold;">
                                        ${score}åˆ†
                                    </div>
                                    <div style="font-size: 16px; color: #666; margin-bottom: 20px;">
                                        ç­”å¯¹ ${correctCount} / ${this.questions.length} é¢˜
                                    </div>
                                    <div style="background: #f0f3ff; padding: 15px; border-radius: 10px; margin-top: 20px;">
                                        <div style="font-size: 14px; color: #666; margin-bottom: 5px;">ç”¨æ—¶</div>
                                        <div style="font-size: 18px; color: #667eea; font-weight: bold;">
                                            ${this.formatTime(this.totalTime)}
                                        </div>
                                    </div>
                                    <div style="margin-top: 20px; font-size: 14px; color: #999;">
                                        âœ“ æˆç»©å·²è‡ªåŠ¨ä¿å­˜
                                    </div>
                                </div>
                            `,
                            allowHtml: true,
                            confirmButtonText: 'å®Œæˆ',
                            closeOnClickOverlay: false
                        });
                    } else {
                        throw new Error(result.error || 'æäº¤å¤±è´¥');
                    }
                    
                } catch (error) {
                    console.error('æäº¤é”™è¯¯:', error);
                    vant.Toast.clear();
                    
                    // å¤±è´¥æ—¶æ˜¾ç¤ºé”™è¯¯
                    vant.Dialog.alert({
                        title: 'æäº¤å¤±è´¥',
                        message: `è‡ªåŠ¨æäº¤å¤±è´¥ï¼Œä½†æˆç»©å·²ä¿å­˜åœ¨æœ¬åœ°ã€‚\n\né”™è¯¯ï¼š${error.message}\n\nè¯·è”ç³»è€å¸ˆè®°å½•æˆç»©ã€‚`,
                        confirmButtonText: 'çŸ¥é“äº†'
                    });
                }
            },
            
            generateBehaviorReport(score, correctCount, wrongQuestions) {
                const typeStats = {};
                this.questionMetrics.forEach(metric => {
                    if (!typeStats[metric.questionType]) {
                        typeStats[metric.questionType] = {
                            total: 0,
                            correct: 0,
                            avgTime: 0,
                            totalTime: 0
                        };
                    }
                    typeStats[metric.questionType].total++;
                    if (metric.isCorrect) {
                        typeStats[metric.questionType].correct++;
                    }
                    typeStats[metric.questionType].totalTime += metric.timeSpent;
                });
                
                Object.keys(typeStats).forEach(type => {
                    typeStats[type].avgTime = Math.round(typeStats[type].totalTime / typeStats[type].total);
                    typeStats[type].accuracy = Math.round((typeStats[type].correct / typeStats[type].total) * 100);
                });
                
                const sortedByTime = [...this.questionMetrics].sort((a, b) => b.timeSpent - a.timeSpent);
                
                return {
                    score: score,
                    correctCount: correctCount,
                    totalQuestions: this.questions.length,
                    totalTime: this.totalTime,
                    avgTimePerQuestion: Math.round(this.totalTime / this.questions.length),
                    wrongQuestions: wrongQuestions,
                    wrongCount: wrongQuestions.length,
                    questionDetails: this.questionMetrics.map(m => ({
                        questionIndex: m.questionIndex,
                        questionType: m.questionType,
                        isCorrect: m.isCorrect,
                        timeSpent: Math.round(m.timeSpent),
                        userAnswer: m.userAnswer,
                        correctAnswer: m.correctAnswer,
                        changeCount: m.changeCount,
                        audioPlayCount: m.audioPlayCount
                    })),
                    typeStatistics: typeStats,
                    patterns: {
                        fastestQuestion: sortedByTime[sortedByTime.length - 1]?.questionIndex || 0,
                        slowestQuestion: sortedByTime[0]?.questionIndex || 0,
                        totalChanges: this.questionMetrics.reduce((sum, m) => sum + m.changeCount, 0),
                        totalAudioPlays: this.questionMetrics.reduce((sum, m) => sum + m.audioPlayCount, 0)
                    },
                    submittedAt: new Date().toISOString()
                };
            }
        }
    }).use(vant).mount('#app');
</script>
</body>
</html>
